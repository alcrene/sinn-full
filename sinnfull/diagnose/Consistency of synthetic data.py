# -*- coding: utf-8 -*-
# ---
# jupyter:
#   jupytext:
#     formats: ipynb,py:percent
#     notebook_metadata_filter: -jupytext.text_representation.jupytext_version
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#   kernelspec:
#     display_name: Python (sinnfull)
#     language: python
#     name: sinnfull
# ---

# %% [markdown]
# # Consistency of Synthetic Data
#
# This notebook checks that the histories generated by a `SyntheticDataAccessor` are consistent with the model used to produce them.
#
# A failure of this test generally indicates a software bug. One possible cause is if random numbers are sampled multiple times. For example, if $u(t) = f(ξ(t))$ depends on a stochastic $ξ(t) \sim \mathcal{N}(\cdot)$, a bug might cause the evaluation of $u$ to be expressed instead as $u(t) = f(\mathcal{N}(\cdot))$ – this would use different random numbers for the values of $ξ(t)$ and $u(t)$.

# %%
import sinnfull
#sinnfull.setup('numpy', view_only=True)  # Numpy is easier to debug, but Theano is
sinnfull.setup('theano', view_only=True)  # what the optimizer actually executes

# %%
import numpy as np
import theano_shim as shim
from smttask import Task
from mackelab_toolbox.utils import GitSHA
from sinnfull.viz import pretty_names, RSView, FitData
from sinnfull.utils import shift_time_t0

# %%
rsview = RSView()

# %%
record = rsview.get('20210608-184539_4efe63')

# %%
segment_sampler = Task.from_desc(record.get_param('optimizer.data_segments')).run()

# %%
model = segment_sampler.data.model

# %%
key, timeslice, data = next(iter(segment_sampler))

# %% [markdown]
# Loaded model parameters match those prescribed by the trial.

# %%
segment_sampler.data.trials.trial[0].data[()].params.input.logσ \
== shim.eval(model.input.logσ)

# %%
shift_time_t0(model, timeslice.start)
K = len(data['time'].sel(time=timeslice))
model.dynamics.u[0:K] = data['dynamics.u'].sel(time=timeslice)
model.dynamics.I[0:K] = data['dynamics.I'].sel(time=timeslice)

# %%
kmin=510; kmax = 515
computed_u = [shim.eval(model.dynamics.u_upd(model.dynamics, k), max_cost=None)
              for k in np.arange(kmin,kmax,dtype=model.time.index_nptype)]
computed_u

# %%
np.isclose(model.dynamics.u.data[kmin:kmax], computed_u)

# %%
kmin=510; kmax = 515
model.input.ξ.data[kmin:kmax]

# %%
model.input.ξ.data[513]

# %% [markdown]
# Compare empirical stationary statistics with the analytical expression

# %%
model.input.ξ.data.std(axis=0)

# %%
shim.eval(model.input.stationary_stats()['ξ']['std'])

# %% [markdown]
# If we don't trust the model method, we can also compute an update “manually” and compare with the recorded value.

# %%
k = 512
Δt = model.dt.magnitude
ukm1 = model.dynamics.u.data[k]
uk = model.dynamics.u.data[k+1]
Ik = model.dynamics.I.data[k+1]
α = shim.eval(model.dynamics.params.α)
β = shim.eval(model.dynamics.params.β)
h = shim.eval(model.dynamics.params.h)
w = shim.eval(model.dynamics.params.w)

# %%
Ik

# %%
ukm1 + (α*Δt) * (-ukm1 + w @ (1+np.exp(-β*(ukm1-h)))**-1 + Ik) # Computed u_k

# %%
uk

# %%
